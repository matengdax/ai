# Shell 相关问答 & C 语言自举知识整理

---

## 1. Bash、tcsh、csh、zsh 的区别与优劣

### Bash（Bourne Again Shell）
- **主流度：**★★★★★
- **特点：** Linux 默认，脚本能力极强，兼容 sh，社区活跃，适合系统管理和自动化。

### Zsh（Z Shell）
- **主流度：**★★★★☆
- **特点：** 交互体验极佳，自动补全和插件丰富，oh-my-zsh 生态强大，脚本兼容性好，适合日常终端和个性化体验。

### Csh / Tcsh（C Shell / TENEX C Shell）
- **主流度：**★☆☆☆☆
- **特点：** 语法类似 C，脚本能力较弱，兼容性差，主要用于少数 BSD 或老系统。

### 总结表

| Shell   | 脚本能力 | 交互体验 | 主流性 | 扩展性 | 推荐用途                  |
|---------|----------|----------|--------|--------|---------------------------|
| bash    | ★★★★★   | ★★★☆☆   | ★★★★★ | ★★★☆☆ | 脚本开发，系统管理        |
| zsh     | ★★★★★   | ★★★★★   | ★★★★☆ | ★★★★★ | 交互日常用，极客个性化    |
| csh     | ★★☆☆☆   | ★★☆☆☆   | ★☆☆☆☆ | ★★☆☆☆ | 历史遗留系统，不推荐新用  |
| tcsh    | ★★☆☆☆   | ★★★☆☆   | ★☆☆☆☆ | ★★☆☆☆ | 部分 BSD 用户             |

---

## 2. Bash vs pksh

- **Bash：** 世界主流 Shell，Linux 默认，功能强大，脚本能力极佳。
- **pksh：** 并非主流 Shell，可能是部分系统对 Korn shell (ksh) 的定制版，但普通用户几乎用不到。主流脚本/日常交互还是推荐 bash 或 zsh。
- **ksh（Korn shell）：** 兼容 sh，比 csh 强大，脚本能力好，传统 Unix 服务器常见，但新项目更推荐 bash。

---

## 3. ksh 主要特点 & 为什么有这么多 sh

### ksh 主要特点
- 兼容 sh，脚本能力更强
- 支持命令别名、命令行历史、补全、数组、进程替换等
- 性能优良，脚本执行效率高
- 语法丰富，支持函数、复杂条件、协程等
- Unix 传统服务器广泛使用

### 为什么有这么多种 sh
- **历史演进**：sh 是 Unix 最早的 shell，后续用户需求多样化，出现了 csh、ksh、bash、zsh 等
- **功能增强**：不同 shell 在交互、语法、扩展性等方面不断创新
- **平台差异**：不同系统、发行版、历史遗留等原因
- **脚本兼容**：新 shell 仍然保持对 sh 脚本的兼容

---

## 4. 为什么 Apple（macOS）默认 shell 从 Bash 改为 Zsh？Zsh 用什么语言写的？

### 原因
- Bash 5.x 及以上用 GPLv3 协议，Apple 出于法律和商业原因不愿引入新版，只能长期停留在 Bash 3.2，非常老旧。
- Zsh 用 MIT 风格等宽松许可证，对商业发行无障碍。
- Zsh 交互体验更好，插件和主题生态丰富。
- 社区趋势，开发者和高级用户更喜欢 zsh。

### Zsh 用什么语言写的？
- Zsh 也是用 **C 语言** 编写的，和 bash 一样。

---

## 5. 用 C 语言自举是什么意思？

### 什么是自举（Bootstrapping）
- 自举是指：一个系统用自身（或前代的简化版）来构建自己。
- 典型例子：**编译器自举**——用 C 语言写的 C 语言编译器能够编译自己的源代码。

### C 语言自举的实际流程
1. 用 C 语言写了一个 C 编译器。
2. 用已有的工具（如早期的 C 编译器或汇编器）首次编译它，得到可执行文件。
3. 这个编译器可以用来编译自己的源代码，不断自我升级和优化。
4. 这样就实现了自给自足和移植性、可维护性。

### 现实意义
- 独立性强，不依赖其他工具。
- 可移植到新平台，只需要最基础工具（如汇编器）。
- 编译器和工具链可以自我维护和进化。

---

## 6. Bash 文件描述符基础知识

### 标准文件描述符
- 0：标准输入（stdin）
- 1：标准输出（stdout）
- 2：标准错误（stderr）

### 其他文件描述符（如 3~44）
- 当你用 `exec 3>file.txt` 等方式打开更多文件或管道时，系统为每个分配一个唯一编号（3、4、…、44等）。
- 这些编号代表“第 N 个被打开的文件或资源”，可以是普通文件、管道、设备、socket、进程替换产生的伪文件等。

### 查看文件描述符实际指向
```bash
ls -l /proc/$$/fd
```
- 可以看到每个 fd 实际指向的文件或设备。

### 通过 echo 写入指定文件描述符
```bash
exec 3> /tmp/test.txt   # 3号fd指向 /tmp/test.txt
echo "hello world" >&3  # 写入内容到 fd 3
exec 3>&-               # 关闭 fd 3
```
---

## 7. Bash 重定向符号解释

- `>&3`：把标准输出重定向到 3 号 fd。
- `2>&1`：标准错误重定向到标准输出。
- `n>&m`：把 n 号 fd 重定向到 m 号 fd。
- `n>&-`：关闭 n 号 fd（如 `exec 3>&-` 关闭 3 号 fd）。
- `>& 3`：**错误写法**，不要用。

---

## 8. `> >(command)` 的用法说明

- `> >(command)` 让左侧命令输出通过管道直接送给括号里的命令（作为标准输入）。
- 例：
  ```bash
  echo "hello world" > >(cat -n)
  ```
  结果会在终端看到加行号的输出。

- 复杂用法示例：
  ```bash
  echo -e "ok\nerror\nok" | tee >(grep error > errors.log) > all.log
  ```
  `all.log` 记录所有内容，`errors.log` 只记录含 error 的行。

---

## 9. 参考资料

- Bash 官方文档：https://www.gnu.org/software/bash/manual/
- Zsh 官方文档：https://zsh.sourceforge.io/Doc/
- “自举” 相关讲解：[维基百科 Bootstrapping](https://en.wikipedia.org/wiki/Bootstrapping_(compilers))
- Apple Shell 切换公告：https://support.apple.com/en-us/HT208050

---